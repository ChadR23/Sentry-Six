<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Minimap Renderer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }
        #minimapContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, 
                rgb(45, 45, 50) 0%, 
                rgb(35, 35, 40) 50%,
                rgb(28, 28, 32) 100%);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.5),
                0 2px 8px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        #minimap {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            background: #1a1a1a;
        }
        .leaflet-container {
            background: #1a1a1a !important;
        }
        .leaflet-tile-pane {
            filter: invert(100%) hue-rotate(180deg) brightness(0.8) contrast(1.2);
        }
        .leaflet-marker-icon {
            filter: none !important;
        }
        .arrow-marker-icon {
            background: transparent !important;
            border: none !important;
            will-change: transform;
        }
        .arrow-marker-icon img {
            will-change: transform;
        }
    </style>
</head>
<body>
    <div id="minimapContainer">
        <div id="minimap"></div>
    </div>
    
    <script>
        let map = null;
        let mapMarker = null;
        let mapPolyline = null;
        let currentRotation = 0;
        
        // Interpolation data
        let gpsData = [];
        const mapZoom = 17;
        
        // IPC setup
        let ipcRenderer;
        try {
            if (typeof require !== 'undefined') {
                ipcRenderer = require('electron').ipcRenderer;
            } else {
                ipcRenderer = { send: () => {}, on: () => {} };
            }
        } catch (err) {
            ipcRenderer = { send: () => {}, on: () => {} };
        }
        
        // Linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        
        // Interpolate heading with wrap-around
        function lerpAngle(a, b, t) {
            let delta = b - a;
            if (delta > 180) delta -= 360;
            if (delta < -180) delta += 360;
            return a + delta * t;
        }
        
        // Get interpolated position for timestamp
        function getInterpolatedPosition(timestampMs) {
            if (gpsData.length === 0) return null;
            
            let before = null;
            let after = null;
            
            for (let i = 0; i < gpsData.length; i++) {
                if (gpsData[i].t <= timestampMs) {
                    before = gpsData[i];
                }
                if (gpsData[i].t >= timestampMs && !after) {
                    after = gpsData[i];
                    break;
                }
            }
            
            if (!before && !after) return null;
            if (!before) return { lat: after.lat, lon: after.lon, heading: after.heading };
            if (!after) return { lat: before.lat, lon: before.lon, heading: before.heading };
            if (before.t === after.t) return { lat: before.lat, lon: before.lon, heading: before.heading };
            
            const t = (timestampMs - before.t) / (after.t - before.t);
            return {
                lat: lerp(before.lat, after.lat, t),
                lon: lerp(before.lon, after.lon, t),
                heading: lerpAngle(before.heading, after.heading, t)
            };
        }
        
        // Initialize map
        function initMap() {
            if (map) return;
            
            map = L.map('minimap', {
                zoomControl: false,
                attributionControl: false,
                dragging: false,
                touchZoom: false,
                scrollWheelZoom: false,
                doubleClickZoom: false,
                boxZoom: false,
                keyboard: false,
                fadeAnimation: false,
                zoomAnimation: false,
                markerZoomAnimation: false
            }).setView([0, 0], mapZoom);
            
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                updateWhenIdle: false,
                updateWhenZooming: false,
                keepBuffer: 8  // Keep more tiles in memory
            }).addTo(map);
        }
        
        // Initialize route polyline
        function initMapPath(pathData) {
            if (!map || !pathData || !pathData.length) return;
            
            const validPath = pathData.filter(coord => {
                const [lat, lon] = coord;
                return lat !== undefined && lon !== undefined &&
                       Number.isFinite(lat) && Number.isFinite(lon) &&
                       !(Math.abs(lat) < 0.001 && Math.abs(lon) < 0.001);
            });
            
            if (validPath.length < 2) return;
            
            mapPolyline = L.polyline(validPath, {
                color: '#0072ff',
                weight: 3,
                opacity: 0.8
            }).addTo(map);
            
            // Start centered on first point
            map.setView(validPath[0], mapZoom, { animate: false });
        }
        
        // Store GPS data for interpolation
        function setGpsData(data) {
            gpsData = data.filter(d => 
                d.lat !== undefined && d.lon !== undefined &&
                Number.isFinite(d.lat) && Number.isFinite(d.lon) &&
                !(Math.abs(d.lat) < 0.001 && Math.abs(d.lon) < 0.001)
            );
            console.log('[MINIMAP] Loaded', gpsData.length, 'GPS points for interpolation');
        }
        
        // Update marker and pan map (DYNAMIC)
        function updateMarker(lat, lon, heading) {
            if (!map) initMap();
            
            const latlng = L.latLng(lat, lon);
            
            // Smooth rotation
            const targetHeading = heading || 0;
            let delta = targetHeading - (currentRotation % 360);
            if (delta > 180) delta -= 360;
            if (delta < -180) delta += 360;
            currentRotation += delta;
            
            if (!mapMarker) {
                currentRotation = targetHeading;
                
                const arrowIcon = L.divIcon({
                    className: 'arrow-marker-icon',
                    html: '<img src="../../assets/arrow.png" style="width: 40px; height: 40px; transform: rotate(' + currentRotation + 'deg); transform-origin: center center; display: block;" />',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                mapMarker = L.marker(latlng, { icon: arrowIcon }).addTo(map);
            } else {
                mapMarker.setLatLng(latlng);
                
                const iconElement = mapMarker._icon;
                if (iconElement) {
                    const imgElement = iconElement.querySelector('img');
                    if (imgElement) {
                        imgElement.style.transform = 'rotate(' + currentRotation + 'deg)';
                    }
                }
            }
            
            // DYNAMIC: Pan map to follow marker
            map.setView(latlng, mapZoom, { animate: false });
        }
        
        // Update by timestamp (interpolated)
        function updateMarkerByTime(timestampMs) {
            const pos = getInterpolatedPosition(timestampMs);
            if (pos) {
                updateMarker(pos.lat, pos.lon, pos.heading);
            }
        }
        
        let isReady = false;
        
        window.addEventListener('DOMContentLoaded', () => {
            initMap();
            isReady = true;
            
            setTimeout(() => {
                if (ipcRenderer?.send) ipcRenderer.send('minimap:ready');
            }, 500);
        });
        
        if (ipcRenderer && ipcRenderer.on) {
            ipcRenderer.on('minimap:init', (event, pathData) => {
                console.log('Minimap received path:', pathData?.length || 0, 'points');
                initMapPath(pathData);
                setTimeout(() => {
                    if (ipcRenderer?.send) ipcRenderer.send('minimap:ready');
                }, 300);
            });
            
            ipcRenderer.on('minimap:setGpsData', (event, data) => {
                setGpsData(data);
                if (ipcRenderer?.send) ipcRenderer.send('minimap:ready');
            });
            
            ipcRenderer.on('minimap:updateByTime', (event, timestampMs) => {
                updateMarkerByTime(timestampMs);
                requestAnimationFrame(() => {
                    if (isReady && ipcRenderer?.send) ipcRenderer.send('minimap:ready');
                });
            });
            
            ipcRenderer.on('minimap:update', (event, lat, lon, heading) => {
                updateMarker(lat, lon, heading);
                requestAnimationFrame(() => {
                    if (isReady && ipcRenderer?.send) ipcRenderer.send('minimap:ready');
                });
            });
        }
    </script>
</body>
</html>
